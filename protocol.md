# 6. http2协议（未校对）

背景介绍就到此为止了，历史的脚步将我们推到了现在这一步。让我们深入看看该协议的细节特性。

**6.1. 二进制**

http2是一个二进制协议。

仔细想想，如果你是一个曾经跟互联网协议打过交道，那你很可能本能反对二进制协议，你甚至准备好了一大堆理由来证明基于文本的协议是多么的有用，正如你曾无数次地通过手工输入HTTP请求来远程登陆。

http2采用二进制主要是为了使成帧更便捷。在HTTP1.1和其他文本协议中，识别帧的起始和结束相当复杂。移除掉可选的空白符和其他冗余，实现变得更容易。

另一方面，从帧结构中分离出协议的特定部分也变得更容易。而在HTTP1中，各个部分相互交织，一团乱麻。

协议的压缩特点和其运行在TLS之上的事实保护了文本的安全<!--diminish the value of text 不太清楚怎么翻译-->，因为根本无法从数据流上看到文本。只有通过类似Wireshark的工具，才能从协议层面对http2一探究竟。

调试这样的协议将需要curl这样的工具，要进一步地分析网络数据流需要类似Wireshark的http2解析器。

**6.2. 二进制格式**

http2发送二进制帧。帧的类型有很多种，但他们都有如下的公共字段：

Type, Length, Flags, Steam Identifier和frame payload

http2的规范一共定义了10种不同的帧，其中最基础的两种分别对应于HTTP 1.1的DATA和HEADERS。接下来我会更详细的介绍一些帧。

**6.3. 多路复用的流**

上一节提到的Stream Identifier定义了二进制帧的格式，每个http2上传输的帧都关联到一个“流”。流是一个逻辑上的结合，一个独立的，双向的帧序列，通过http2连接客户端和服务器端。

每个单独的http2连接都可以包含多个并发的流，任何一端都可以交错地插入帧。流既可以被客户端/服务器端单方面的建立、使用，也可以被双方共享。同时，两边都可以关闭流。在同一个流里面，每一帧发送的顺序非常关键。接收方会按照收到帧的顺序来进行处理。

流的多路复用意味着在同一连接中来自各个流的包被混合在一起。两个（或者更多）独立的“数据列车”被拼凑到了一辆列车上，最终在终点站被分开。下面就是两列“数据火车”

![][1]

他们就是这样通过多路复用的方式被塞到了同一列火车上。

![][2]

在http2里面，我们很容易可以看到10个甚至100个同时并存的流。创建一个新的流的代价也非常低。

**6.4. 优先级和依赖关系**

每个流都包含一个优先级，优先级被用来告诉对端哪个流更重要。

优先级的工作细节在协议中被改变多次，至今仍在讨论。关键点在于怎样让客户端指定哪个流更重要，并且需要一个依赖参数，这样一个流才能被指定依赖于另外一个。

优先级能动态的被改变，这可以让用户滚动一个全是图片的页面的时候，浏览器可以指定哪个图片有更高的优先级。或者是在你切换标签页的时候，浏览器可以指定新页面所包含流的优先级。

**6.5. 头压缩**

HTTP是无状态协议。简而言之，这意味着每个请求必须要包含服务器需要的所有细节，而不是让服务器保存住之前请求的元数据。因为http2没有改变这些范式，所以它也需要这样。

这也让HTTP成为可重复的。当一个客户端从同一服务器请求一些资源（例如页面的图片）的时候，这些请求看起来几乎是一致的。而这些大量一致的东西正好是需要被压缩的。

当每个页面资源的个数上升的时候，cookies的使用和请求的大小都会增加，而每个请求都会包含的cookie几乎是一模一样的。

HTTP 1.1的请求包大小变得越来越大，有时甚至会大于TCP窗口的初始大小，这也让请求收到含有ACK的回复，发送请求变得非常慢<!--这句需要review-->。同样，这也是需要压缩的理由。

**6.5.1. 压缩是非常棘手的课题**

HTTPS和SPDY的压缩存在受[BREACH](http://en.wikipedia.org/wiki/BREACH_%28security_exploit%29)和[CRIME](http://en.wikipedia.org/wiki/CRIME)攻击的隐患。通过向流中注入一些已知的文本，再观察输出的变化，可以推出原始发送的数据。

对协议的动态内容进行压缩使其免于攻击，需要一些仔细的思考和细致的考虑。这正是HTTPbis小组的尝试。

[HPACK](http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12)http2头部压缩，顾名思义，它是一个专为http2头部设计的压缩格式，严格地说来，它在一个单独的协议草案中被指定。新格式使充分利用这种压缩变得困难，而其他的解决方法，比如用一个位请求中间人不压缩指定的头部和帧的可选填充，也是如此。

用Roberto Peon（HPACK的设计者之一）的话说，“HPACK旨在提供一个一致性的实现使信息量的损失尽可能少，使编解码快速而方便，使接收方能控制压缩文本的大小，允许代理重新建立索引<!-没太理解 re-index 指的什么-->（如，通过代理在前后端共享状态），以及对哈夫曼编码串的更快速比较”。


**6.6. 重置 - 后悔药**

HTTP 1.1的一个缺点是当一个含有确切值的Content-Length的HTTP消息被送出之后，我们就很难中断它了。当然，通常我们可以断开整个TCP链接（但也不总是可以这样，具体原因在这里我不展开），但这样导致的代价就是需要重新通过三次握手建立一个新的TCP连接。

如果可能的话，我们当然希望能立即终止当前消息的发送并重新发一个新的。在http2里面，我们可以通过发送RST_STREAM帧来实现这种需求，从而防止带宽的浪费，避免断开已有的连接。

**6.7. 服务器推送**

这个功能通常被称作“缓存推送”。主要的思想是：如果一个客户端请求资源X，而服务器知道该客户端很可能同样也需要资源Z，所以服务器端主动将资源Z发送回客户端。这个功能帮助客户端将Z放进缓存以备将来之需。

服务器推送需要客户端显式的允许服务器提供该功能。但即使如此，客户端依然能自主选择是否真的需要该推送的流，如果不需要的话，客户端可以通过发送一个RST——STREAM来中止。

**6.8. 流量控制**

http2上面每个流都拥有自己的公开流量窗，它可以限制另一端发送数据。如果你正好知道SSH的工作原理的话，这两者非常相似。

对于每个流来说，两端都需要告诉对方自己还有更多的空间来接受新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。只有数据帧受流量控制。


[1]: ./imgs/multiplexing_1.png
[2]: ./imgs/multiplexing_2.png
