# 6. http2协议（未完成）

背景介绍就到此为止了，历史的脚步将我们推到了现在这一步。让我们深入看看该协议的细节特性。

**6.1. 二进制**

http2是一个二进制协议。

仔细想想，如果你是一个曾经跟互联网协议打过交道，那你很可能本能反对二进制协议。

**6.2. 二进制格式**

http2发送二进制帧。几种帧都有相同的设置：

Type, Length, Flags, Steam Identifier和frame payload

http2的规范一共定义了10种不同的帧，其中最基础的两种分别对应于HTTP 1.1的DATA和HEADERS。接下来我会更详细的介绍一些帧。

**6.3. 多路复用的流**

上一节提到的Stream Identifier定义了二进制帧的格式，这让http2上传输的所有帧关联到一个“流”。流是一个逻辑上的结合，一个独立的，双向的连续帧客户端和服务器端交换的http2连接。

每个单独的http2连接都可以包含多个并发的流，。流既可以被客户端/服务器端单方面的建立、使用，也可以被双方共享。同时，两边都可以关闭流。在同一个流里面，每一帧发送的顺序非常关键。接收方会按照收到帧的顺序来进行处理。

流的多路复用意味着在同一连接中，每个包可能混合在多个流里面。两个（或者更多）独立的“数据火车”被拼凑到了一列车上，再在终点站被分开。下面就是两列“数据火车”

【图】

他们就是这样用多路复用的方式被塞到了同一列火车上。

【图】

在http2里面，我们很容易可以看到10个甚至100个同时并存的流。创建一个新的流的代价也非常低。

**6.4. 优先级和依赖关系**

每个流都包含一个优先级，优先级被用来告诉同伴哪个流更加的重要。

优先级在协议里具体的工作原理改变了很多次，当前也仍然在讨论。关键点在于客户端要能指定哪个流更重要，并且该参数需要是一个依赖参数，这样一个流才能依赖于另外一个。

优先级能动态的被改变，这可以让用户滚动一个全是图片的页面的时候，浏览器可以指定哪个图片有更高的优先级。或者是在你切换标签页的时候，浏览器可以指定新页面所包含流的优先级。

**6.5. 头压缩**

HTTP是无状态协议。简而言之，这意味着每个请求必须要包含服务器需要的所有细节，而不是让服务器保存住之前请求的元数据。因为http2没有改变这些范式，所以它也需要这样。

这也让HTTP成为可重复的。当一个客户端从同一服务器请求一些资源（例如页面的图片）的时候，这些请求看起来几乎是一致的。而这些大量一致的东西正好是需要被压缩的。

当每个页面资源的个数上升的时候，cookies的使用和请求的大小都会增加。然后每个请求都会包含的cookie几乎是一模一样的。

HTTP 1.1的请求大小变得越来越大，到现在甚至会大于默认的TCP窗口大小，这也让请求收到含有ACK的回复，发送请求变得非常慢。同样，这也是需要压缩的理由。

**6.5.1. 压缩是非常棘手的主题**

HTTPS和SPDY的压缩存在受[BREACH](http://en.wikipedia.org/wiki/BREACH_%28security_exploit%29)和[CRIME](http://en.wikipedia.org/wiki/CRIME)攻击的隐患。通过向流中注入一些已知的文本，再观察输出的变化，可以推出原始发送的数据。

防止此类攻击并且对动态内容进行压缩，需要一些仔细的思考和细致的考虑。这也是HTTPbis小组试着去做的。

**6.6. 重置 - 改变主意**

HTTP 1.1的一个缺点是当一个含有确切值的Content-Length的HTTP消息被送出之后，我们就很难中断它了。当然，通常我们可以断开整个TCP链接（但也不总是可以这样，具体原因在这里我不展开），但这样导致的代价就是需要重新通过三次握手建立一个新的TCP连接。

如果可能的话，我们当然希望能中止一个消息传输，而不是断开连接再创建新的。在http2里面，我们可以通过发送RST——STREAM帧来实现这种需求，从而防止贷款的浪费，避免断开已有的连接。

**6.7. 服务器推送**

这个功能通常被称作“缓存推送”。主要的思想是：如果一个客户端请求资源X，而服务器知道该客户端其实很可能需要的是资源Z，所以服务器端主动将资源Z发送回客户端。这个功能帮助客户端将Z放进缓存以备将来之需。

服务器推送需要客户端显式的允许服务器提供该功能。但即使如此，客户端依然能自主选择是否真的需要该推送的流，如果不需要的话，客户端可以通过发送一个RST——STREAM来中止。

**6.8. 流程控制**

http2上面每个流都拥有自己的建议流程窗口，它可以限制另一端发送数据。如果你正好知道SSH的工作原理的话，这两者非常相似。

对于每个流来说，两端都需要告诉对方自己还有更多的空间来接受新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。只有数据帧被这种流程控制。


